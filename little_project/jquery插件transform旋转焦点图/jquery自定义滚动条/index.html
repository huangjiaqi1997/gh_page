<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Title</title>
	<link rel="stylesheet" type="text/css" href="style.css" media="screen">
</head>
<body>
    <div class="scroll-demo">

	    <ul class="scroll-tab">
		    <li class="tab-item tab-active">第1幕</li>
		    <li class="tab-item">第2幕</li>
		    <li class="tab-item">第3幕</li>
		    <li class="tab-item">第4幕</li>
	    </ul>

	    <div class="scroll-wrap">
		    <div class="scroll-cont">
			    <h3 class="anchor">春天来了</h3>
			    <div class="scroll-ol">
				    <p>LiveStyle是css实时编辑工具，(它的功能)与流行起来的工具如LiveReload，CodeKit等类似，这些工具背后的思想很简单：你在编辑器中编辑css文件后，保存，然后惊奇的发现，浏览器中的页面(指的是前面编辑后保存的样式文件的页面)会自动刷新，会给你带来由于css样式改变而形成视觉上的反馈。</p>
				    <p>绝大多数的实时编辑工具的工作流程都是这样的：监听已知文件夹中文件的更新情况，然后做一些额外的工作(例如，将LESS转成CSS)，最后(将样式变化的地方)更新到网页。这就意味着，你必须要保存你的源文件，然后等待几秒可以观察到，细微的改变如何影响你的页面。</p>
				    <p>LiveStyle开启一种实时编辑体验：当你在文本编辑器中打字的时候，(LiveStyle)即时同步更新网页，不用等到文件保存或者页面预加载。并且LiveStyle是第一个能够将在浏览器开发工具栏的变化以正确的方式同步更新到源代码中</p>
				    <p>LiveStyle开启一种实时编辑体验：当你在文本编辑器中打字的时候，(LiveStyle)即时同步更新网页，不用等到文件保存或者页面预加载。并且LiveStyle是第一个能够将在浏览器开发工具栏的变化以正确的方式同步更新到源代码中</p>
				    <p>LiveStyle开启一种实时编辑体验：当你在文本编辑器中打字的时候，(LiveStyle)即时同步更新网页，不用等到文件保存或者页面预加载。并且LiveStyle是第一个能够将在浏览器开发工具栏的变化以正确的方式同步更新到源代码中</p>
				    <p>LiveStyle开启一种实时编辑体验：当你在文本编辑器中打字的时候，(LiveStyle)即时同步更新网页，不用等到文件保存或者页面预加载。并且LiveStyle是第一个能够将在浏览器开发工具栏的变化以正确的方式同步更新到源代码中</p>
			    </div>
			    <h3 class="anchor">夏天来了</h3>
			    <div class="scroll-ol">
				    <p>LiveStyle弹出框显示可以在当前页面获取的样式表的列表，每一个浏览器LiveStyle弹出框(当前页所拥有的)样式表位置下面是一个包含所有样式表(指的是用编辑器打开的样式表)的下拉菜单。为了开始使用LiveStyle，你只需要让LiveStyle在当前页面可以使用，然后就是将浏览器样式表和编辑器打开的样式表进行关联起来。在那以后，在编辑器上对样式表进行的改动将会同步到浏览器指定的样式表中，反之亦然。 有时候你可能想限制浏览器和编辑器之间的样式更新以及保存功能，例如编辑器到浏览器更新，所以你用浏览器开发工具栏对样式修改的操作不会破坏源代码。为了实现上述功能，只需要点击蓝色按钮来循环选择更新模式： </p>
				    <p>最简单的方式就是使用LiveStyle应用:</p>
				    <p>1.为你的操作系统下载LiveStyle应用(暂时还不支持Linux，请使用手动安装方法)。</p>
				    <p>最简单的方式就是使用LiveStyle应用:</p>
				    <p>1.为你的操作系统下载LiveStyle应用(暂时还不支持Linux，请使用手动安装方法)。</p>
				    <p>LiveStyle弹出框显示可以在当前页面获取的样式表的列表，每一个浏览器LiveStyle弹出框(当前页所拥有的)样式表位置下面是一个包含所有样式表(指的是用编辑器打开的样式表)的下拉菜单。为了开始使用LiveStyle，你只需要让LiveStyle在当前页面可以使用，然后就是将浏览器样式表和编辑器打开的样式表进行关联起来。在那以后，在编辑器上对样式表进行的改动将会同步到浏览器指定的样式表中，反之亦然。 有时候你可能想限制浏览器和编辑器之间的样式更新以及保存功能，例如编辑器到浏览器更新，所以你用浏览器开发工具栏对样式修改的操作不会破坏源代码。为了实现上述功能，只需要点击蓝色按钮来循环选择更新模式： </p>
				    <p>Windows用户：当你首次运行LiveStyle，Windows可能会请求接入网络，请允许该请求。在下载插件以及Remote View是需要接入网络的。</p>
				    <p>2.解压然后运行。</p>
				    <p>Windows用户：当你首次运行LiveStyle，Windows可能会请求接入网络，请允许该请求。在下载插件以及Remote View是需要接入网络的。</p>
			    </div>
			    <h3 class="anchor">秋天来了</h3>
			    <div class="scroll-ol">
				    <p>LiveStyle弹出框显示可以在当前页面获取的样式表的列表，每一个浏览器LiveStyle弹出框(当前页所拥有的)样式表位置下面是一个包含所有样式表(指的是用编辑器打开的样式表)的下拉菜单。为了开始使用LiveStyle，你只需要让LiveStyle在当前页面可以使用，然后就是将浏览器样式表和编辑器打开的样式表进行关联起来。在那以后，在编辑器上对样式表进行的改动将会同步到浏览器指定的样式表中，反之亦然。 有时候你可能想限制浏览器和编辑器之间的样式更新以及保存功能，例如编辑器到浏览器更新，所以你用浏览器开发工具栏对样式修改的操作不会破坏源代码。为了实现上述功能，只需要点击蓝色按钮来循环选择更新模式： </p>
				    <p>LiveStyle弹出框显示可以在当前页面获取的样式表的列表，每一个浏览器LiveStyle弹出框(当前页所拥有的)样式表位置下面是一个包含所有样式表(指的是用编辑器打开的样式表)的下拉菜单。为了开始使用LiveStyle，你只需要让LiveStyle在当前页面可以使用，然后就是将浏览器样式表和编辑器打开的样式表进行关联起来。在那以后，在编辑器上对样式表进行的改动将会同步到浏览器指定的样式表中，反之亦然。 有时候你可能想限制浏览器和编辑器之间的样式更新以及保存功能，例如编辑器到浏览器更新，所以你用浏览器开发工具栏对样式修改的操作不会破坏源代码。为了实现上述功能，只需要点击蓝色按钮来循环选择更新模式： </p>
				    <p>LiveStyle弹出框显示可以在当前页面获取的样式表的列表，每一个浏览器LiveStyle弹出框(当前页所拥有的)样式表位置下面是一个包含所有样式表(指的是用编辑器打开的样式表)的下拉菜单。为了开始使用LiveStyle，你只需要让LiveStyle在当前页面可以使用，然后就是将浏览器样式表和编辑器打开的样式表进行关联起来。在那以后，在编辑器上对样式表进行的改动将会同步到浏览器指定的样式表中，反之亦然。 有时候你可能想限制浏览器和编辑器之间的样式更新以及保存功能，例如编辑器到浏览器更新，所以你用浏览器开发工具栏对样式修改的操作不会破坏源代码。为了实现上述功能，只需要点击蓝色按钮来循环选择更新模式： </p>
				    <p>LiveStyle弹出框显示可以在当前页面获取的样式表的列表，每一个浏览器LiveStyle弹出框(当前页所拥有的)样式表位置下面是一个包含所有样式表(指的是用编辑器打开的样式表)的下拉菜单。为了开始使用LiveStyle，你只需要让LiveStyle在当前页面可以使用，然后就是将浏览器样式表和编辑器打开的样式表进行关联起来。在那以后，在编辑器上对样式表进行的改动将会同步到浏览器指定的样式表中，反之亦然。 有时候你可能想限制浏览器和编辑器之间的样式更新以及保存功能，例如编辑器到浏览器更新，所以你用浏览器开发工具栏对样式修改的操作不会破坏源代码。为了实现上述功能，只需要点击蓝色按钮来循环选择更新模式： </p>
			    </div>
			    <h3 class="anchor">冬天来了</h3>
			    <div class="scroll-ol">
				    <p>首先我们应该创建实时更新所需的会话以便我们如何简单又快乐的使用LiveStyle！</p>
				    <p>你现在可以进行下一步啦！在Sublime Text中，在.sample-content__title {...}规则中将颜色属性值改变成红色，然后你应该可以看到内容变成红色！把玩了.sample-content__title {...}然后添加例如background: yellow;规则。</p>
			    </div>
			    <div class="correct-bot"></div>
		    </div>

		    <div class="scroll-bar">
			    <div class="scroll-slider"></div>
		    </div>
	    </div>
    </div>
<script src="../../jquery-3.2.1.js"></script>
    <script src="script.js"></script>
<!--<script>-->
	<!--(function (win, doc, $) {-->
		<!--function CusScrollBar(options) {-->
			<!--this._init(options);-->

		<!--}-->


		<!--$.extend(CusScrollBar.prototype, {-->

			<!--_init: function (options) {-->
				<!--var self = this;-->
				<!--self.options = {-->
					<!--scrollDir: "y",-->
					<!--contSelector: "", //滚动条选择器-->
				    <!--barSelector: "", //滚动条选择器-->
					<!--sliderSelector: "", //滚动块选择器-->
					<!--wheelStep: 20, //滚轮步长-->
					<!--tabItemSelector: ".tab-item", //标签选择器-->
					<!--tabActiveClass: "tab-active", //选中标签类名-->
					<!--anchorSelector: ".anchor", //锚点选择器-->
					<!--correctSelector: ".correct-bot", //补全选择器-->
				    <!--articleSelector: ".scroll-ol" //文章选择器-->

				<!--}-->
				<!--$.extend(true, self.options, options || {});-->

				<!--self._initDomEvent();-->

				<!--return self;-->

			<!--},-->

			<!--/*初始化DOM引用*/-->
			<!--_initDomEvent: function () {-->
				<!--var opts = this.options;-->
				<!--this.$cont = $(opts.contSelector);-->
				<!--this.$slider = $(opts.sliderSelector);-->
				<!--this.$bar = opts.barSelector ? $(opts.barSelector) : self.$slider.parent();-->
				<!--this.$tabItems = $(opts.tabItemSelector);-->
				<!--this.$anchor = $(opts.anchorSelector);-->
				<!--this.$article = $(opts.articleSelector);-->
				<!--this.$correct = $(opts.correctSelector);-->
				<!--this.$doc = $(doc);-->
				<!--this._initSliderDragEvent()-->
					<!--._bindContScroll()-->
					<!--._bindMousewheel()-->
					<!--._initTabEvent()-->
					<!--._initArticleHeight();-->


			<!--},-->

			<!--/*补全最后段文档高度*/-->
			<!--_initArticleHeight: function () {-->
				<!--var self = this,-->
					<!--lastArticle = self.$article.last();-->
				<!--var lastArticleHeight = lastArticle.height(),-->
					<!--contHeight = self.$cont.height();-->
				<!--if (lastArticleHeight < contHeight) {-->
					<!--self.$correct[0].style.height = contHeight - lastArticleHeight -self.$anchor.outerHeight() +'px';-->
				<!--}-->
				<!--return self;-->
			<!--},-->

			<!--/*滑块的mousedown、mousemove、mouseup事件，计算数据，触发scrollTo*/-->
			<!--_initSliderDragEvent: function () {-->
				<!--var self = this,-->
			        <!--slider = this.$slider,-->
					<!--sliderEl = slider[0];-->

				<!--if (sliderEl) {-->
					<!--var doc = this.$doc,-->
						<!--dragStartPagePosition, //定义移动的相关变量-->
						<!--dragStartScrollPosition,-->
						<!--dragContBarRate;-->

					<!--function mousemoveHander(e) {-->
						<!--e.preventDefault();-->
						<!--console.log('move');-->
						<!--if (dragStartPagePosition === null){-->
							<!--return;-->
						<!--}-->
						<!--self.scrollTo(dragStartPagePosition + (e.pageY - dragStartPagePosition) * dragContBarRate); //触发scroll函数-->
					<!--}-->

					<!--slider.on('mousedown', function (e) {-->
						<!--e.preventDefault();console.log('down');-->
						<!--dragStartPagePosition = e.pageY;-->
						<!--dragStartScrollPosition = self.$cont[0].scrollTop;-->
						<!--dragContBarRate = self.getMaxScrollPosition()/self.getMaxSliderPosition();-->
						<!--doc.on('mousemove.scroll', mousemoveHander).on('mouseup.scroll',function () {-->
							<!--console.log('up');-->
							<!--doc.off('.scroll');-->
						<!--});-->

					<!--})-->
				<!--}-->
				<!--return self;-->
			<!--},-->

			<!--//点击标签，获取index 1：改变标签className-->
			<!--// 2：根据该项锚点位置，调用scrollTo，拉拽内容-->
			<!--_initTabEvent: function () {-->
				<!--var self = this;-->
				<!--self.$tabItems.on('click', function (e) {-->
					<!--e.preventDefault();-->
					<!--var index = $(this).index();-->
					<!--self.changeTabSelect(index);-->

					<!--self.scrollTo(self.$cont[0].scrollTop + self.getAnchorPosition(index));-->
				<!--})-->
				<!--return self;-->
			<!--},-->

			<!--//锚点到上边界的像素数 相对于wrap div-->

			<!--getAnchorPosition: function (index) {-->
				<!--return this.$anchor.eq(index).position().top;-->
			<!--},-->

			<!--//获取每个锚点位置信息的数组 卷起高度+锚点到上边界距离-->
			<!--getAllAnchorPosition: function () {-->
				<!--var self = this,-->
					<!--allPositionArr = [];-->
				<!--for (var i = 0; i < self.$anchor.length; i++) {-->
					<!--allPositionArr.push(self.$cont[0].scrollTop + self.getAnchorPosition(i));-->
				<!--}-->
				<!--return allPositionArr;-->
			<!--},-->

			<!--//改变标签className-->
			<!--changeTabSelect: function (index) {-->
				<!--var self = this,-->
					<!--active = self.options.tabActiveClass;-->
				<!--return self.$tabItems.eq(index).addClass(active).siblings().removeClass(active);-->
			<!--},-->

			<!--//内容滚动，触发scroll事件，调用getSliderPosition：计算滑块位置-->
			<!--_bindContScroll: function () {-->
				<!--var self = this;-->
				<!--self.$cont.on('scroll', function () {-->
					<!--var sliderEl = self.$slider && self.$slider[0];-->
					<!--if (sliderEl) {-->
						<!--sliderEl.style.top = self.getSliderPosition() +'px';-->
					<!--}-->
				<!--});-->
				<!--return self;-->
			<!--},-->

			<!--//内容区鼠标滚轮事件，获取滚动数据*步长 -> 调用scrollTo-->
			<!--_bindMousewheel: function () {-->
				<!--var self = this;-->
				<!--self.$cont.on('mousewheel DOMMouseScroll', function (e) {-->
					<!--e.preventDefault();-->
					<!--var oEv = e.originalEvent, //JQ获取原生事件对象-->
						<!--wheelRange = oEv.wheelDelta ? -oEv.wheelDelta / 120 : (oEv.detail || 0) / 3;-->

					<!--self.scrollTo(self.$cont[0].scrollTop + wheelRange * self.options.wheelStep);-->
				<!--});-->
				<!--return self;-->
			<!--},-->
			<!--//计算滑块当前位置-->
			<!--getSliderPosition: function () {-->
				<!--var self = this,-->
					<!--maxSliderPosition = self.getMaxSliderPosition();-->
				<!--return Math.min(maxSliderPosition, maxSliderPosition * self.$cont[0].scrollTop / self.getMaxScrollPosition());-->
			<!--},-->

			<!--//内容可滚动高度-->
			<!--getMaxScrollPosition: function () {-->
				<!--var self = this; //$cont.height: 可视区高度-->
				<!--return Math.max(self.$cont.height(), self.$cont[0].scrollHeight) - self.$cont.height();-->
			<!--},-->
			<!--//滑块可移动距离-->
			<!--getMaxSliderPosition: function () {-->
				<!--var self = this;-->
				<!--return self.$bar.height() - self.$slider.height();-->
			<!--},-->

			<!--//根据scrollTop函数设让内容滚动-->
			<!--//positionVal:卷起的长度-->
			<!--scrollTo: function (positionVal) {-->
				<!--var self = this;-->
				<!--var posArr = self.getAllAnchorPosition();-->
				<!--//遍历数组中锚点距离 和 scrollTo移动距离比较-->
				<!--function getIndex(positionVal) {-->
					<!--for (var i = posArr.length - 1; i >= 0; i&#45;&#45;) { //大->小-->
						<!--if (positionVal >= posArr[i]) { //作图观察-->
							<!--return i;-->
						<!--} else {-->
							<!--continue;-->
						<!--}-->
					<!--}-->
				<!--}-->
				<!--if (posArr.length === self.$tabItems.length) {-->
					<!--self.changeTabSelect(getIndex(positionVal));-->
				<!--}-->
				<!--self.$cont.scrollTop(positionVal);-->
			<!--}-->
		<!--});-->












		<!--win.CusScrollBar = CusScrollBar;-->
	<!--})(window, document, jQuery);-->


	<!--new CusScrollBar({-->
		<!--contSelector: ".scroll-cont",-->
		<!--barSelector: ".scroll-bar",-->
		<!--sliderSelector: ".scroll-slider"-->
	<!--});-->
<!--</script>-->
</body>
</html>